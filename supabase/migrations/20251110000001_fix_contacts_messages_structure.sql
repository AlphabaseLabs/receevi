-- ============================================================================
-- Migration: Fix contacts and messages table structure
-- This migration restructures contacts and messages to match additional_schema.sql
-- IMPORTANT: This drops and recreates tables - only for new systems!
-- ============================================================================

-- ============================================================================
-- DROP DEPENDENT OBJECTS
-- ============================================================================

-- Drop triggers on messages first
DROP TRIGGER IF EXISTS trg_msg_10_touch_contact ON messages;
DROP TRIGGER IF EXISTS trg_msg_20_touch_session ON messages;
DROP TRIGGER IF EXISTS trg_msg_30_pick_intent ON messages;
DROP TRIGGER IF EXISTS trg_msg_40_echo_handover ON messages;

-- Drop policies on messages and contacts
DROP POLICY IF EXISTS "Enable delete for admin users only on messages" ON messages;
DROP POLICY IF EXISTS "Enable insert for admin users and agent users to their contacts" ON messages;
DROP POLICY IF EXISTS "Enable select for admin users and agent users to their contacts" ON messages;
DROP POLICY IF EXISTS "Enable update for admin users and agent users to their contacts" ON messages;

DROP POLICY IF EXISTS "Enable delete for admin users only on contacts" ON contacts;
DROP POLICY IF EXISTS "Enable insert for admin users only on contacts" ON contacts;
DROP POLICY IF EXISTS "Enable select for admin users and agent users to their contacts" ON contacts;
DROP POLICY IF EXISTS "Enable update for admin users and agent users to their contacts" ON contacts;

-- Drop dependent tables
DROP TABLE IF EXISTS appointment_reminders CASCADE;
DROP TABLE IF EXISTS messages CASCADE;
DROP TABLE IF EXISTS conversations CASCADE;

-- Drop and recreate contacts table with correct structure
DROP TABLE IF EXISTS contacts CASCADE;

-- ============================================================================
-- RECREATE CONTACTS TABLE (correct structure)
-- ============================================================================

CREATE TABLE "public"."contacts" (
    "id" BIGSERIAL PRIMARY KEY,
    "tenant_id" UUID NOT NULL REFERENCES "tenants"("id") ON DELETE CASCADE,
    "phone_number_id" UUID REFERENCES "phone_numbers"("id"),
    "wa_id" TEXT NOT NULL,
    "profile_name" TEXT,
    "tags" TEXT[] NOT NULL DEFAULT '{}',
    "in_chat" BOOLEAN NOT NULL DEFAULT FALSE,
    "assigned_to" TEXT,
    "unread_count" INTEGER NOT NULL DEFAULT 0,
    "last_message_at" TIMESTAMP WITH TIME ZONE,
    "last_message_received_at" TIMESTAMP WITH TIME ZONE,
    "opted_out" BOOLEAN NOT NULL DEFAULT FALSE,
    "voided" BOOLEAN NOT NULL DEFAULT FALSE,
    "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    UNIQUE ("tenant_id", "wa_id")
);

-- Indexes for contacts
CREATE INDEX idx_contacts_tenant_wa ON contacts(tenant_id, wa_id);
CREATE INDEX idx_contacts_tenant_last ON contacts(tenant_id, last_message_at DESC);
CREATE INDEX idx_contacts_profile_trgm ON contacts USING gin (profile_name gin_trgm_ops);

-- ============================================================================
-- RECREATE MESSAGES TABLE (correct structure with FK)
-- ============================================================================

CREATE TABLE "public"."messages" (
    "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "chat_id" BIGINT NOT NULL,
    "message" JSONB NOT NULL,
    "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    "media_url" TEXT,
    "wam_id" CHARACTER VARYING NOT NULL,
    "delivered_at" TIMESTAMP WITH TIME ZONE,
    "read_at" TIMESTAMP WITH TIME ZONE,
    "sent_at" TIMESTAMP WITH TIME ZONE,
    "is_received" BOOLEAN NOT NULL DEFAULT FALSE,
    "read_by_user_at" TIMESTAMP WITH TIME ZONE,
    "failed_at" TIMESTAMP WITH TIME ZONE,
    CONSTRAINT messages_wam_id_key UNIQUE (wam_id),
    CONSTRAINT messages_chat_fk FOREIGN KEY (chat_id) REFERENCES contacts(id) ON DELETE CASCADE
);

-- Index for messages
CREATE INDEX idx_messages_chat_time ON messages(chat_id, created_at DESC);

-- ============================================================================
-- RECREATE CONVERSATIONS TABLE (correct FK to contacts.id)
-- ============================================================================

CREATE TABLE "public"."conversations" (
    "id" UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    "tenant_id" UUID NOT NULL REFERENCES "tenants"("id") ON DELETE CASCADE,
    "phone_number_id" UUID REFERENCES "phone_numbers"("id"),
    "contact_id" BIGINT NOT NULL,
    "status" conversation_mode NOT NULL DEFAULT 'bot',
    "assigned_to_label" TEXT,
    "mute_bot_until" TIMESTAMP WITH TIME ZONE,
    "session_expires_at" TIMESTAMP WITH TIME ZONE,
    "active_flow_key" TEXT,
    "flow_state" JSONB NOT NULL DEFAULT '{}'::jsonb,
    "flow_status" TEXT NOT NULL DEFAULT 'idle' CHECK ("flow_status" IN ('idle','running','paused','completed','failed')),
    "last_user_msg_at" TIMESTAMP WITH TIME ZONE,
    "last_agent_msg_at" TIMESTAMP WITH TIME ZONE,
    "voided" BOOLEAN NOT NULL DEFAULT FALSE,
    "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    UNIQUE ("tenant_id", "contact_id", "phone_number_id"),
    CONSTRAINT conversations_contact_id_fkey FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
);

-- Indexes for conversations
CREATE INDEX idx_conversations_tenant_number_status ON conversations(tenant_id, phone_number_id, status);
CREATE INDEX idx_conversations_tenant_updated ON conversations(tenant_id, updated_at DESC);

-- ============================================================================
-- RECREATE APPOINTMENT REMINDERS TABLE (with correct FK)
-- ============================================================================

CREATE TABLE "public"."appointment_reminders" (
    "id" UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    "contact_id" BIGINT NOT NULL,
    "send_by" CHARACTER VARYING(20) NOT NULL,
    "cancel_by" CHARACTER VARYING(20),
    "status" CHARACTER VARYING(50) NOT NULL,
    "template_id" CHARACTER VARYING NOT NULL,
    "patient_response" TEXT,
    "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    "appointment_uuid" UUID,
    CONSTRAINT appointment_reminders_contact_id_fkey FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
);

-- Indexes for appointment_reminders
CREATE INDEX idx_appointment_reminders_cancel_by ON appointment_reminders(cancel_by);
CREATE INDEX idx_appointment_reminders_created_at ON appointment_reminders(created_at);
CREATE INDEX idx_appointment_reminders_send_by ON appointment_reminders(send_by);
CREATE INDEX idx_appointment_reminders_status ON appointment_reminders(status);
CREATE INDEX idx_appointment_reminders_contact_id ON appointment_reminders(contact_id);

-- ============================================================================
-- RECREATE TRIGGER FUNCTIONS (updated for new structure)
-- ============================================================================

-- Touch contact on message
CREATE OR REPLACE FUNCTION fn_touch_contact_on_message()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  UPDATE contacts c
     SET last_message_at = new.created_at,
         last_message_received_at = CASE WHEN new.is_received THEN new.created_at ELSE c.last_message_received_at END,
         unread_count = CASE WHEN new.is_received THEN COALESCE(c.unread_count,0) + 1 ELSE c.unread_count END
   WHERE c.id = new.chat_id
     AND c.voided = false;
  RETURN new;
END $$;

-- Touch session window
CREATE OR REPLACE FUNCTION fn_touch_session_window()
RETURNS trigger LANGUAGE plpgsql AS $$
DECLARE c_rec contacts;
BEGIN
  IF new.is_received THEN
    SELECT * INTO c_rec FROM contacts WHERE id = new.chat_id AND voided = false;
    IF FOUND THEN
      INSERT INTO conversations (
        tenant_id, phone_number_id, contact_id,
        session_expires_at, last_user_msg_at, updated_at
      )
      VALUES (
        c_rec.tenant_id, c_rec.phone_number_id, c_rec.id,
        new.created_at + interval '24 hours', new.created_at, now()
      )
      ON CONFLICT (tenant_id, contact_id, phone_number_id) DO UPDATE
        SET session_expires_at = excluded.session_expires_at,
            last_user_msg_at   = excluded.last_user_msg_at,
            updated_at         = now();
    END IF;
  END IF;
  RETURN new;
END $$;

-- Pick intent on inbound
CREATE OR REPLACE FUNCTION fn_pick_intent_on_inbound()
RETURNS trigger LANGUAGE plpgsql AS $$
DECLARE c_rec contacts; msg text; chosen_key text;
BEGIN
  IF NOT new.is_received THEN RETURN new; END IF;

  SELECT * INTO c_rec FROM contacts WHERE id = new.chat_id AND voided = false;
  IF NOT FOUND THEN RETURN new; END IF;

  msg := lower(get_msg_text(new.message));

  SELECT bi.key INTO chosen_key
    FROM bot_intents bi
   WHERE bi.tenant_id = c_rec.tenant_id
     AND bi.active AND bi.voided = false
     AND (
          (bi.is_regex = false AND position(lower(bi.phrase) IN msg) > 0)
       OR (bi.is_regex = true  AND msg ~* bi.phrase)
     )
   ORDER BY bi.priority DESC, bi.created_at ASC
   LIMIT 1;

  UPDATE conversations
     SET active_flow_key = COALESCE(chosen_key, active_flow_key),
         flow_status     = CASE WHEN chosen_key IS NOT NULL THEN 'running' ELSE flow_status END,
         updated_at      = now()
   WHERE tenant_id = c_rec.tenant_id
     AND phone_number_id = c_rec.phone_number_id
     AND contact_id = c_rec.id
     AND voided = false;

  RETURN new;
END $$;

-- Echo handover (minimal & safe)
CREATE OR REPLACE FUNCTION fn_echo_handover_min_safe()
RETURNS trigger LANGUAGE plpgsql AS $$
DECLARE
  ts timestamptz := COALESCE(new.created_at, now());
  mute_seconds int;
  c_rec contacts;
  p_rec phone_numbers;
  t_rec tenants;
BEGIN
  -- outbound only
  IF new.is_received THEN RETURN new; END IF;

  -- detect echo flag in payload
  IF NOT (COALESCE((new.message->>'origin')='agent_app',false)
          OR COALESCE((new.message->>'echo')::boolean,false)) THEN
    RETURN new;
  END IF;

  -- resolve settings via contact -> phone_number -> tenant
  SELECT * INTO c_rec FROM contacts WHERE id = new.chat_id AND voided = false;
  IF NOT FOUND THEN RETURN new; END IF;

  SELECT * INTO p_rec FROM phone_numbers WHERE id = c_rec.phone_number_id AND voided = false;
  SELECT * INTO t_rec FROM tenants WHERE id = c_rec.tenant_id AND voided = false;

  IF COALESCE(p_rec.auto_handover_on_echo, true) IS FALSE THEN
    RETURN new;
  END IF;

  SELECT COALESCE(p_rec.echo_handover_mute_seconds, t_rec.echo_handover_mute_seconds, 86400)
    INTO mute_seconds;
  IF mute_seconds IS NULL THEN RETURN new; END IF;

  -- upsert conversation, set human + extend mute
  INSERT INTO conversations (tenant_id, phone_number_id, contact_id, status, mute_bot_until, last_agent_msg_at, updated_at)
  VALUES (c_rec.tenant_id, c_rec.phone_number_id, c_rec.id, 'human', ts + (mute_seconds || ' seconds')::interval, ts, now())
  ON CONFLICT (tenant_id, contact_id, phone_number_id) DO UPDATE
    SET status          = 'human',
        mute_bot_until  = GREATEST(conversations.mute_bot_until, excluded.mute_bot_until),
        last_agent_msg_at = ts,
        updated_at      = now();

  -- optional UI hint
  UPDATE contacts
     SET in_chat = true
   WHERE id = c_rec.id AND voided = false;

  RETURN new;
END $$;

-- ============================================================================
-- RECREATE TRIGGERS
-- ============================================================================

CREATE TRIGGER trg_msg_10_touch_contact
AFTER INSERT ON messages
FOR EACH ROW EXECUTE FUNCTION fn_touch_contact_on_message();

CREATE TRIGGER trg_msg_20_touch_session
AFTER INSERT ON messages
FOR EACH ROW EXECUTE FUNCTION fn_touch_session_window();

CREATE TRIGGER trg_msg_30_pick_intent
AFTER INSERT ON messages
FOR EACH ROW EXECUTE FUNCTION fn_pick_intent_on_inbound();

CREATE TRIGGER trg_msg_40_echo_handover
AFTER INSERT ON messages
FOR EACH ROW EXECUTE FUNCTION fn_echo_handover_min_safe();

CREATE TRIGGER appointment_reminders_update_updated_at
BEFORE UPDATE ON appointment_reminders
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- ROW LEVEL SECURITY
-- ============================================================================

-- Enable RLS
ALTER TABLE contacts ENABLE ROW LEVEL SECURITY;
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;

-- Contacts policies (using tenant_id for multi-tenancy)
CREATE POLICY "contacts_select_policy" ON contacts
FOR SELECT TO authenticated
USING (
    -- Admin can see all contacts in their tenant
    (tenant_id::text = COALESCE(auth.jwt()->>'tenant_id','') AND voided = false) OR
    -- Agent role check can be added here if needed
    ((SELECT auth.jwt() -> 'user_metadata' ->> 'custom_user_role') = 'admin')
);

CREATE POLICY "contacts_insert_policy" ON contacts
FOR INSERT TO authenticated
WITH CHECK (
    (tenant_id::text = COALESCE(auth.jwt()->>'tenant_id','')) OR
    ((SELECT auth.jwt() -> 'user_metadata' ->> 'custom_user_role') = 'admin')
);

CREATE POLICY "contacts_update_policy" ON contacts
FOR UPDATE TO authenticated
USING (
    (tenant_id::text = COALESCE(auth.jwt()->>'tenant_id','')) OR
    ((SELECT auth.jwt() -> 'user_metadata' ->> 'custom_user_role') = 'admin')
)
WITH CHECK (
    (tenant_id::text = COALESCE(auth.jwt()->>'tenant_id','')) OR
    ((SELECT auth.jwt() -> 'user_metadata' ->> 'custom_user_role') = 'admin')
);

CREATE POLICY "contacts_delete_policy" ON contacts
FOR DELETE TO authenticated
USING (
    ((SELECT auth.jwt() -> 'user_metadata' ->> 'custom_user_role') = 'admin')
);

-- Messages policies (via contacts join for tenant isolation)
CREATE POLICY "messages_select_policy" ON messages
FOR SELECT TO authenticated
USING (
    chat_id IN (
        SELECT id FROM contacts
        WHERE (tenant_id::text = COALESCE(auth.jwt()->>'tenant_id','') AND voided = false)
           OR (SELECT auth.jwt() -> 'user_metadata' ->> 'custom_user_role') = 'admin'
    )
);

CREATE POLICY "messages_insert_policy" ON messages
FOR INSERT TO authenticated
WITH CHECK (
    chat_id IN (
        SELECT id FROM contacts
        WHERE (tenant_id::text = COALESCE(auth.jwt()->>'tenant_id',''))
           OR (SELECT auth.jwt() -> 'user_metadata' ->> 'custom_user_role') = 'admin'
    )
);

CREATE POLICY "messages_update_policy" ON messages
FOR UPDATE TO authenticated
USING (
    chat_id IN (
        SELECT id FROM contacts
        WHERE (tenant_id::text = COALESCE(auth.jwt()->>'tenant_id',''))
           OR (SELECT auth.jwt() -> 'user_metadata' ->> 'custom_user_role') = 'admin'
    )
)
WITH CHECK (
    chat_id IN (
        SELECT id FROM contacts
        WHERE (tenant_id::text = COALESCE(auth.jwt()->>'tenant_id',''))
           OR (SELECT auth.jwt() -> 'user_metadata' ->> 'custom_user_role') = 'admin'
    )
);

CREATE POLICY "messages_delete_policy" ON messages
FOR DELETE TO authenticated
USING (
    ((SELECT auth.jwt() -> 'user_metadata' ->> 'custom_user_role') = 'admin')
);

-- ============================================================================
-- GRANTS
-- ============================================================================

GRANT DELETE, INSERT, REFERENCES, SELECT, TRIGGER, TRUNCATE, UPDATE ON TABLE "public"."appointment_reminders" TO "anon";
GRANT DELETE, INSERT, REFERENCES, SELECT, TRIGGER, TRUNCATE, UPDATE ON TABLE "public"."appointment_reminders" TO "authenticated";
GRANT DELETE, INSERT, REFERENCES, SELECT, TRIGGER, TRUNCATE, UPDATE ON TABLE "public"."appointment_reminders" TO "service_role";

-- ============================================================================
-- REALTIME PUBLICATION
-- ============================================================================

-- Add tables to realtime publication
DO $$
BEGIN
  -- Add tables to publication (ignore if already exists)
  BEGIN
    ALTER PUBLICATION supabase_realtime ADD TABLE contacts;
  EXCEPTION
    WHEN duplicate_object THEN NULL;
  END;

  BEGIN
    ALTER PUBLICATION supabase_realtime ADD TABLE messages;
  EXCEPTION
    WHEN duplicate_object THEN NULL;
  END;

  BEGIN
    ALTER PUBLICATION supabase_realtime ADD TABLE conversations;
  EXCEPTION
    WHEN duplicate_object THEN NULL;
  END;
END $$;
